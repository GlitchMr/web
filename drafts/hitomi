use v6;

grammar XML {
    regex TOP { ^ <pi>* <xmlcontent>+ {*} $ };

    token xmlcontent {
        | <node>           {*} #= node
        | <empty>          {*} #= empty
        | <content>        {*} #= content
    };

    rule node {
        '<' <name=ident> <attrs> '>'
        <xmlcontent>+
        '</' $<name> '>'
        {*}
    }

    rule pi { '<!' <.ident> <.ident> '>' };

    rule empty   { '<'  <name=ident> <attrs> '/>' {*} };

    token attrs { <attr>* {*} }
    rule attr { $<name>=[<.ident>[':'<.ident>]?] '=' '"' $<value>=[<-["]>+] '"' }

    token ident { <+alnum + [\-]>+ }

    regex content { <-[<]>+ {*} }
};

class XML::Node {
    has $.name is rw;
    has %.attrs is rw;
    has @.contents is rw;
    method Str {
        my $str = "<$.name";
        $str ~= [~] map {" $^k=\"$^v\""}, %.attrs.kv;
        $str ~=">";
        $str ~= [~] @.contents;
        $str ~= "</$.name>";
        return $str;
    }
}

class XML::Actions {
    method TOP($/) {
        make gather for $<xmlcontent> {
            take .ast;
        }
    }

    method xmlcontent($/, $key) {
        make $/{$key}.ast;
    }

    method node($/) {
        my @items = gather for $<xmlcontent> {
            take .ast;
        }
        make XML::Node.new(
            :name(~$<name>),
            :contents(@items),
            :attrs($<attrs>.ast),
        );
    }

    method empty($/) {
        make XML::Node.new(
            :name(~$<name>),
            :attrs($<attrs>.ast),
        );
    }

    method attrs($/) {
        my %a;
        for @($<attr>) {
            %a{~.<name>} = ~.<value> if $_;
        }
        make %a;
    }
    method content($/) {
        make ~$/;
    }
}

my $xml = $*IN.slurp;
my $result = XML.parse($xml, :action(XML::Actions.new()));
(~.value).print for $result.chunks;
